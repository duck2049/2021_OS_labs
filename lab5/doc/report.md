本实验主要的修改在于：
1. 添加了若干内核源码文件以及他们的makefile
  - /myOS/kernel/task.c 
  - /myOS/include/task.h
  - /myOS/i386/CTX_SW.S

2. 修改了若干原有的代码
  - 在myMain函数的最后调用endTask来使其可以被调度器调度（准确的说 可以在运行完之后把控制交还给调度器）
  - 编写了用户态的task0 1 2 并且使用了task的格式编写

3. 调度器的理论依据
  - x86的程序运行逻辑  
  x86程序使用很少的几个寄存器，主要通过一个位于内存的栈来进行很多通用操作。  
  一般来说 一个函数的是这样工作的：  
  进入函数的时候 通过栈寄存器传入目前可用的栈的最大地址（形象的说 esp=777的时候 表示这个程序可用自由的使用内存下标小于等于777的内存空间 自由的往下用）  
  从esp开始不断的把原有的通用寄存器的内容push到栈中（在栈顶保存调用者的现场）   
  然后快乐的把各种局部变量都用栈顶指针的偏移量来定义，比如局部变量a b c就会被分配到栈顶往下的1，2，3个位置，这种感觉。  
  然后跑完之后 所有的局部变量就可以丢弃掉了，然后从栈顶里面pop出来原来的通用寄存器（还原现场）  

  总结的来说，对于x86处理器来说，只要保证三个东西一致，就可以确保他们后续的行为。这三个东西就是 栈指针寄存器esp，指令指针寄存器epi，以及通用寄存器组。这意味着在我们的实验中，只要确保栈指针寄存器可以赋值为我们分配的内存位置，指令指针寄存器epi指向目标函数的进入点位置，通用寄存器由于我们的进程内部会对他们初始化所以其实不用特地去改他们。
  
  - ret命令的运行方式  
  ret的实质是从栈中pop出来一个地址，写入到指令指针寄存器eip中，所以可以利用他来实现跳转，这样的优点在于只要给定栈顶寄存器的内容和栈顶指向的内存内容，就可以简单的让他跳转到给定的函数入口。

了解以上的理论基础之后，介绍一下代码的主要工作
- 核心数据结构 myTCB 里面包含了一个初始化完成的栈顶指针，这个栈里面已经push进了一些东西，把这个新的栈顶交给CTX_SW后，CTX_SW会完成如下工作：用栈里面的东西初始化通用寄存器，初始化esp，使用ret指令让cpu自动从栈顶再pop一个数出来作为继续运行的地址（这个栈的位置被我们设计为task目标的函数），于是就完成了切换上下文的步骤（由于本实验中的进程完全没有重入的可能性，因此CTX_SW中保存前一个task的工作现场的功能实际上没有实际意义，所以忽略前面一半的介绍）（重入是指一个进程运行了一半之后，处于某些原因被调度器剥夺了CPU，而一段时间后又通过还原现场的方式恢复他的运行，我们实验中所有进程都是在运行完后调用endTSK来告知调度器已经运行完成，从而释放CPU并且删除进程，所以不存在恢复运行的问题）

- 然后基于FCFS的task manager本质上就是一个队列，一开始就是初始化队列，createTSK就是建立一个新的TCB,然后给他放到队列里面，然后startTSK就是调用CTX_SW来实现上下文切换，endTASK实际上就是进程向调度器返还CPU控制权用的一个函数入口名，destoryTask就是把目标进程从队列里面找出来然后删掉，schedule就是找到队列的尾部节点，然后用它startTSK。